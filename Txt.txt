// Classe Pixel para representar coordenadas
class Pixel {
    private int x;
    private int y;
    
    public Pixel(int x, int y) {
        this.x = x;
        this.y = y;
    }
    
    public int getX() {
        return x;
    }
    
    public int getY() {
        return y;
    }
}

// Interface para estruturas de dados
interface EstruturaPixel {
    void adicionar(Pixel pixel);
    Pixel remover();
    boolean estaVazia();
}

// Implementação própria de Pilha
class PilhaPixel implements EstruturaPixel {
    private static class No {
        Pixel pixel;
        No proximo;
        
        No(Pixel pixel) {
            this.pixel = pixel;
            this.proximo = null;
        }
    }
    
    private No topo;
    
    public PilhaPixel() {
        this.topo = null;
    }
    
    @Override
    public void adicionar(Pixel pixel) {
        No novoNo = new No(pixel);
        novoNo.proximo = topo;
        topo = novoNo;
    }
    
    @Override
    public Pixel remover() {
        if (estaVazia()) {
            return null;
        }
        
        Pixel pixel = topo.pixel;
        topo = topo.proximo;
        return pixel;
    }
    
    @Override
    public boolean estaVazia() {
        return topo == null;
    }
}

// Implementação própria de Fila
class FilaPixel implements EstruturaPixel {
    private static class No {
        Pixel pixel;
        No proximo;
        
        No(Pixel pixel) {
            this.pixel = pixel;
            this.proximo = null;
        }
    }
    
    private No inicio;
    private No fim;
    
    public FilaPixel() {
        this.inicio = null;
        this.fim = null;
    }
    
    @Override
    public void adicionar(Pixel pixel) {
        No novoNo = new No(pixel);
        
        if (estaVazia()) {
            inicio = novoNo;
            fim = novoNo;
        } else {
            fim.proximo = novoNo;
            fim = novoNo;
        }
    }
    
    @Override
    public Pixel remover() {
        if (estaVazia()) {
            return null;
        }
        
        Pixel pixel = inicio.pixel;
        inicio = inicio.proximo;
        
        if (inicio == null) {
            fim = null;
        }
        
        return pixel;
    }
    
    @Override
    public boolean estaVazia() {
        return inicio == null;
    }
}

// Classe para gerenciar cores
class GerenciadorCor {
    public static boolean coresSaoIguais(int cor1, int cor2) {
        return cor1 == cor2;
    }
    
    public static int obterCorBranca() {
        return 0xFFFFFFFF; // Branco em formato ARGB
    }
    
    public static int obterCorVermelha() {
        return 0xFFFF0000; // Vermelho em formato ARGB
    }
    
    public static int obterCorAzul() {
        return 0xFF0000FF; // Azul em formato ARGB
    }
    
    public static int obterCorVerde() {
        return 0xFF00FF00; // Verde em formato ARGB
    }
}

// Classe principal do algoritmo Flood Fill
class FloodFillAlgoritmo {
    private int[][] matriz;
    private int largura;
    private int altura;
    private int corOriginal;
    private int novaCor;
    private EstruturaPixel estrutura;
    private ProcessadorImagem processador;
    
    public FloodFillAlgoritmo(int[][] matriz, ProcessadorImagem processador) {
        this.matriz = matriz;
        this.altura = matriz.length;
        this.largura = matriz[0].length;
        this.processador = processador;
    }
    
    public void preencherComPilha(int x, int y, int novaCor) {
        this.estrutura = new PilhaPixel();
        executarFloodFill(x, y, novaCor, "Pilha");
    }
    
    public void preencherComFila(int x, int y, int novaCor) {
        this.estrutura = new FilaPixel();
        executarFloodFill(x, y, novaCor, "Fila");
    }
    
    private void executarFloodFill(int x, int y, int novaCor, String tipoEstrutura) {
        if (!coordenadaValida(x, y)) {
            System.out.println("Coordenada inicial inválida!");
            return;
        }
        
        this.corOriginal = matriz[y][x];
        this.novaCor = novaCor;
        
        // Se a cor já for a mesma, não há necessidade de preencher
        if (GerenciadorCor.coresSaoIguais(corOriginal, novaCor)) {
            System.out.println("A cor original já é igual à nova cor!");
            return;
        }
        
        System.out.println("Iniciando Flood Fill com " + tipoEstrutura);
        System.out.println("Posição inicial: (" + x + ", " + y + ")");
        System.out.println("Cor original: " + Integer.toHexString(corOriginal));
        System.out.println("Nova cor: " + Integer.toHexString(novaCor));
        
        // Adiciona o pixel inicial à estrutura
        estrutura.adicionar(new Pixel(x, y));
        
        int pixelsProcessados = 0;
        
        // Loop principal do algoritmo
        while (!estrutura.estaVazia()) {
            Pixel pixelAtual = estrutura.remover();
            
            if (pixelAtual == null) {
                continue;
            }
            
            int px = pixelAtual.getX();
            int py = pixelAtual.getY();
            
            // Verifica se o pixel é válido e tem a cor original
            if (coordenadaValida(px, py) && 
                GerenciadorCor.coresSaoIguais(matriz[py][px], corOriginal)) {
                
                // Pinta o pixel atual
                matriz[py][px] = novaCor;
                pixelsProcessados++;
                
                // Salva imagem a cada 50 pixels processados (para animação)
                if (pixelsProcessados % 50 == 0) {
                    processador.salvarImagemAnimacao(matriz, pixelsProcessados, tipoEstrutura);
                }
                
                // Adiciona os 4 vizinhos à estrutura
                adicionarVizinhos(px, py);
            }
        }
        
        System.out.println("Flood Fill concluído! Pixels processados: " + pixelsProcessados);
        
        // Salva a imagem final
        processador.salvarImagemFinal(matriz, tipoEstrutura);
    }
    
    private void adicionarVizinhos(int x, int y) {
        // Vizinho superior
        if (coordenadaValida(x, y - 1)) {
            estrutura.adicionar(new Pixel(x, y - 1));
        }
        
        // Vizinho inferior
        if (coordenadaValida(x, y + 1)) {
            estrutura.adicionar(new Pixel(x, y + 1));
        }
        
        // Vizinho esquerdo
        if (coordenadaValida(x - 1, y)) {
            estrutura.adicionar(new Pixel(x - 1, y));
        }
        
        // Vizinho direito
        if (coordenadaValida(x + 1, y)) {
            estrutura.adicionar(new Pixel(x + 1, y));
        }
    }
    
    private boolean coordenadaValida(int x, int y) {
        return x >= 0 && x < largura && y >= 0 && y < altura;
    }
    
    public void imprimirMatriz() {
        System.out.println("Estado atual da matriz:");
        for (int i = 0; i < altura; i++) {
            for (int j = 0; j < largura; j++) {
                if (matriz[i][j] == GerenciadorCor.obterCorBranca()) {
                    System.out.print("B ");
                } else if (matriz[i][j] == 0xFF000000) { // Preto
                    System.out.print("P ");
                } else if (matriz[i][j] == GerenciadorCor.obterCorVermelha()) {
                    System.out.print("V ");
                } else if (matriz[i][j] == GerenciadorCor.obterCorAzul()) {
                    System.out.print("A ");
                } else {
                    System.out.print("? ");
                }
            }
            System.out.println();
        }
        System.out.println();
    }
}

// Classe para processamento de imagens
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import javax.imageio.ImageIO;

class ProcessadorImagem {
    private String diretorioSaida;
    
    public ProcessadorImagem(String diretorioSaida) {
        this.diretorioSaida = diretorioSaida;
        criarDiretorio();
    }
    
    private void criarDiretorio() {
        File dir = new File(diretorioSaida);
        if (!dir.exists()) {
            dir.mkdirs();
        }
    }
    
    public int[][] carregarImagem(String caminhoArquivo) {
        try {
            BufferedImage imagem = ImageIO.read(new File(caminhoArquivo));
            int largura = imagem.getWidth();
            int altura = imagem.getHeight();
            int[][] matriz = new int[altura][largura];
            
            for (int y = 0; y < altura; y++) {
                for (int x = 0; x < largura; x++) {
                    matriz[y][x] = imagem.getRGB(x, y);
                }
            }
            
            System.out.println("Imagem carregada: " + largura + "x" + altura + " pixels");
            return matriz;
            
        } catch (IOException e) {
            System.err.println("Erro ao carregar imagem: " + e.getMessage());
            return criarMatrizExemplo();
        }
    }
    
    private int[][] criarMatrizExemplo() {
        System.out.println("Criando matriz de exemplo 10x10...");
        int[][] matriz = new int[10][10];
        
        // Preenche com branco
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 10; j++) {
                matriz[i][j] = GerenciadorCor.obterCorBranca();
            }
        }
        
        // Adiciona uma linha diagonal preta
        for (int i = 0; i < 10; i++) {
            if (i < 10) {
                matriz[i][i] = 0xFF000000; // Preto
            }
        }
        
        // Adiciona algumas bordas pretas
        for (int i = 0; i < 10; i++) {
            matriz[0][i] = 0xFF000000; // Borda superior
            matriz[9][i] = 0xFF000000; // Borda inferior
            matriz[i][0] = 0xFF000000; // Borda esquerda
            matriz[i][9] = 0xFF000000; // Borda direita
        }
        
        return matriz;
    }
    
    public void salvarImagemAnimacao(int[][] matriz, int frame, String tipo) {
        try {
            BufferedImage imagem = criarBufferedImage(matriz);
            String nomeArquivo = String.format("%s/animacao_%s_frame_%04d.png", 
                                             diretorioSaida, tipo.toLowerCase(), frame);
            ImageIO.write(imagem, "PNG", new File(nomeArquivo));
        } catch (IOException e) {
            System.err.println("Erro ao salvar frame de animação: " + e.getMessage());
        }
    }
    
    public void salvarImagemFinal(int[][] matriz, String tipo) {
        try {
            BufferedImage imagem = criarBufferedImage(matriz);
            String nomeArquivo = String.format("%s/resultado_final_%s.png", 
                                             diretorioSaida, tipo.toLowerCase());
            ImageIO.write(imagem, "PNG", new File(nomeArquivo));
            System.out.println("Imagem final salva: " + nomeArquivo);
        } catch (IOException e) {
            System.err.println("Erro ao salvar imagem final: " + e.getMessage());
        }
    }
    
    private BufferedImage criarBufferedImage(int[][] matriz) {
        int altura = matriz.length;
        int largura = matriz[0].length;
        BufferedImage imagem = new BufferedImage(largura, altura, BufferedImage.TYPE_INT_ARGB);
        
        for (int y = 0; y < altura; y++) {
            for (int x = 0; x < largura; x++) {
                imagem.setRGB(x, y, matriz[y][x]);
            }
        }
        
        return imagem;
    }
}

// Classe principal para demonstração
public class FloodFillMain {
    public static void main(String[] args) {
        System.out.println("=== SISTEMA FLOOD FILL ===");
        System.out.println("Implementação com Pilha e Fila próprias");
        System.out.println();
        
        // Inicializa o processador de imagens
        ProcessadorImagem processador = new ProcessadorImagem("output");
        
        // Carrega a imagem (ou cria uma de exemplo se não encontrar)
        int[][] matriz = processador.carregarImagem("input.png");
        
        // Cria uma cópia da matriz para testar com fila
        int[][] matrizFila = copiarMatriz(matriz);
        
        // Cria o algoritmo
        FloodFillAlgoritmo algoritmo = new FloodFillAlgoritmo(matriz, processador);
        
        System.out.println("Matriz inicial:");
        algoritmo.imprimirMatriz();
        
        // Testa com Pilha
        System.out.println("=== TESTANDO COM PILHA ===");
        algoritmo.preencherComPilha(1, 1, GerenciadorCor.obterCorVermelha());
        algoritmo.imprimirMatriz();
        
        // Testa com Fila (usando a cópia da matriz original)
        System.out.println("=== TESTANDO COM FILA ===");
        FloodFillAlgoritmo algoritmoFila = new FloodFillAlgoritmo(matrizFila, processador);
        algoritmoFila.preencherComFila(1, 1, GerenciadorCor.obterCorAzul());
        algoritmoFila.imprimirMatriz();
        
        System.out.println("Execução concluída! Verifique as imagens na pasta 'output'.");
    }
    
    private static int[][] copiarMatriz(int[][] original) {
        int altura = original.length;
        int largura = original[0].length;
        int[][] copia = new int[altura][largura];
        
        for (int i = 0; i < altura; i++) {
            for (int j = 0; j < largura; j++) {
                copia[i][j] = original[i][j];
            }
        }
        
        return copia;
    }
}